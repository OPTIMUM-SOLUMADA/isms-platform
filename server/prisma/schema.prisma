// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
  // output   = "../src/generated/prisma"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

// ===========================================================================================
// DEPARTMENT
// ===========================================================================================
model Department {
  id          String  @id @default(auto()) @map("_id") @db.ObjectId
  name        String  @unique
  description String?

  roles DepartmentRole[] @relation()

  createdById String? @db.ObjectId
  createdBy   User?   @relation(name: "CreatedDepartments", fields: [createdById], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("departments")
}

model DepartmentRole {
  id          String  @id @default(auto()) @map("_id") @db.ObjectId
  name        String  @unique
  description String?

  departmentId String     @db.ObjectId
  department   Department @relation(fields: [departmentId], references: [id], onDelete: Cascade)

  createdById String? @db.ObjectId
  createdBy   User?   @relation("DepartmentRolesCreated", fields: [createdById], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  departmentRoleDocuments DepartmentRoleDocument[]
  departmentRoleUsers     DepartmentRoleUser[]

  @@unique([departmentId, name]) // un rôle est unique par département
  @@map("department_roles")
}

// ===========================================================================================
// USERS MANAGEMENT AND ROLES
// ===========================================================================================

enum RoleType {
  ADMIN
  CONTRIBUTOR
  REVIEWER
  VIEWER
}

model User {
  id           String    @id @default(auto()) @map("_id") @db.ObjectId
  email        String    @unique
  name         String?
  role         RoleType  @default(VIEWER)
  isActive     Boolean   @default(false)
  lastLogin    DateTime?
  // ssoId        String?   @unique
  passwordHash String?

  passwordResetToken String?

  // Who created this user
  createdById String? @db.ObjectId
  createdBy   User?   @relation("CreatedUsers", fields: [createdById], references: [id], onDelete: NoAction, onUpdate: NoAction)

  //Relation
  documentReviews   DocumentReview[]
  documentApprovals DocumentApproval[]
  notifications     Notification[]
  auditLogs         AuditLog[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  departmentRoleUsers DepartmentRoleUser[]

  metadata                Json?
  documentAuthors         DocumentAuthor[]   @relation("DocumentAuthorUser")
  documentReviewers       DocumentReviewer[] @relation("DocumentReviewerUser")
  assignedDocumentReviews DocumentReview[]   @relation("Assigner")
  reviewsCompleted        DocumentReview[]   @relation("ReviewCompletedBy")
  createdVersions         DocumentVersion[]  @relation("VersionCreatedByUser")

  // Reverse relations: must break referential action cycles
  createdUsers           User[]                   @relation("CreatedUsers")
  invitationsSent        Invitation[]             @relation("InvitationsSent")
  createdDocumentTypes   DocumentType[]           @relation("CreatedDocumentTypes")
  createdDepartments     Department[]             @relation("CreatedDepartments")
  createdDepartmentRoles DepartmentRole[]         @relation("DepartmentRolesCreated")
  createdISOClauses      ISOClause[]              @relation("CreatedISOClauses")
  recentlyViews          RecentlyViewedDocument[]
  nonConformity          NonConformity[]
  correctiveAction       CorrectiveAction[]

  @@index([email, isActive])
  @@index([role])
  @@map("users")
}

// Relation between document and department role
model DepartmentRoleDocument {
  id               String @id @default(auto()) @map("_id") @db.ObjectId
  departmentRoleId String @db.ObjectId
  documentId       String @db.ObjectId

  // Prisma relations
  document       Document       @relation(fields: [documentId], references: [id], onDelete: Cascade)
  departmentRole DepartmentRole @relation(fields: [departmentRoleId], references: [id], onDelete: Cascade)

  @@map("departmentrole_documents")
}

// Relation between user and department role
model DepartmentRoleUser {
  id               String @id @default(auto()) @map("_id") @db.ObjectId
  departmentRoleId String @db.ObjectId
  userId           String @db.ObjectId

  // Prisma relations
  user           User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  departmentRole DepartmentRole @relation(fields: [departmentRoleId], references: [id], onDelete: Cascade)

  @@map("departmentrole_users")
}

model Invitation {
  id          String           @id @default(auto()) @map("_id") @db.ObjectId
  email       String
  token       String           @unique
  status      InvitationStatus @default(PENDING)
  invitedBy   User             @relation(name: "InvitationsSent", fields: [invitedById], references: [id])
  invitedById String           @db.ObjectId
  acceptedAt  DateTime?
  expiresAt   DateTime
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  @@map("invitations")
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  EXPIRED
  CANCELED
}

// ===========================================================================================
// DOCUMENTS MANAGEMENT AND POLITICS
// ===========================================================================================

model DocumentType {
  id          String     @id @default(auto()) @map("_id") @db.ObjectId
  name        String     @unique
  description String?
  // isoClauseNumber String?
  documents   Document[]

  createdById String? @db.ObjectId
  createdBy   User?   @relation(name: "CreatedDocumentTypes", fields: [createdById], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("document_types")
}

enum DocumentStatus {
  DRAFT
  IN_REVIEW
  APPROVED
  EXPIRED
}

enum ReviewFrequency {
  DAILY
  WEEKLY
  MONTHLY
  QUARTERLY
  SEMI_ANNUAL
  YEARLY
  BIENNIAL
  AS_NEEDED
}

enum Classification {
  CONFIDENTIAL
  INTERNAL_USE_ONLY
  PUBLIC
}

model Document {
  id              String           @id @default(auto()) @map("_id") @db.ObjectId
  title           String
  description     String?
  fileUrl         String?
  status          DocumentStatus   @default(DRAFT)
  nextReviewDate  DateTime?
  reviewFrequency ReviewFrequency?
  isoClauseId     String           @db.ObjectId

  published       Boolean   @default(false)
  publicationDate DateTime?

  classification Classification @default(CONFIDENTIAL)

  departmentRoles DepartmentRoleDocument[]

  categoryId String?       @db.ObjectId
  ownerId    String        @db.ObjectId
  owner      DocumentOwner @relation(name: "DocumentOwner", fields: [ownerId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  folderId String?

  isoClause     ISOClause          @relation(fields: [isoClauseId], references: [id])
  type          DocumentType?      @relation(fields: [categoryId], references: [id])
  versions      DocumentVersion[]
  reviews       DocumentReview[]
  approvals     DocumentApproval[]
  notifications Notification[]
  reviewers     DocumentReviewer[] @relation("DocumentReviewerDocument")

  authors            DocumentAuthor[]         @relation("DocumentAuthorDocument")
  recentlyViews      RecentlyViewedDocument[]
  documentCompliance DocumentCompliance[]
  nonConformity      NonConformity[]

  @@index([title])
  @@map("documents")
}

model DocumentOwner {
  id   String  @id @default(auto()) @map("_id") @db.ObjectId
  name String  @unique
  logo String?

  documents Document[] @relation("DocumentOwner")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("document_owners")
}

model DocumentAuthor {
  id         String @id @default(auto()) @map("_id") @db.ObjectId
  documentId String @db.ObjectId
  userId     String @db.ObjectId

  document Document @relation(name: "DocumentAuthorDocument", fields: [documentId], references: [id], onDelete: Cascade)
  user     User     @relation(name: "DocumentAuthorUser", fields: [userId], references: [id], onDelete: Cascade)

  @@map("document_authors")
}

model DocumentReviewer {
  id         String @id @default(auto()) @map("_id") @db.ObjectId
  documentId String @db.ObjectId
  userId     String @db.ObjectId

  document Document @relation(name: "DocumentReviewerDocument", fields: [documentId], references: [id], onDelete: Cascade)
  user     User     @relation(name: "DocumentReviewerUser", fields: [userId], references: [id], onDelete: Cascade)

  @@map("document_reviewers")
}

model ISOClause {
  id          String     @id @default(auto()) @map("_id") @db.ObjectId
  code        String     @unique
  name        String
  description String?
  documents   Document[]

  createdById String? @db.ObjectId
  createdBy   User?   @relation(name: "CreatedISOClauses", fields: [createdById], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  clauseCompliance  ClauseCompliance[]

  @@map("iso_clauses")
}

model DocumentVersion {
  id                String   @id @default(auto()) @map("_id") @db.ObjectId
  documentId        String   @db.ObjectId
  version           String
  comment           String?
  createdAt         DateTime @default(now())
  isCurrent         Boolean  @default(false) // optional: flag the latest version
  fileUrl           String?
  downloadUrl       String?
  draftId           String?
  draftUrl          String?
  googleDriveFileId String
  createdById       String?  @db.ObjectId
  createdBy         User?    @relation(name: "VersionCreatedByUser", fields: [createdById], references: [id], onDelete: SetNull)

  document        Document           @relation(fields: [documentId], references: [id], onDelete: Cascade)
  approvals       DocumentApproval[]
  documentReviews DocumentReview[]   @relation("ReviewDocumentVersion")

  @@index([documentId, version])
  @@map("document_versions")
}

// ===========================================================================================
// REVIEWS SYSTEM, APPROVAL AND NOTIFICATIONS
// ===========================================================================================
enum ReviewDecision {
  APPROVE
  REJECT
  REQUEST_CHANGES
}

// Ce modèle est plus robuste et inclut l'état de la révision et les commentaire
model DocumentReview {
  id                String          @id @default(auto()) @map("_id") @db.ObjectId
  documentId        String          @db.ObjectId
  reviewerId        String          @db.ObjectId
  assignedById      String?         @db.ObjectId
  comment           String? // Ajouté : Pour "commenter une politique pendant le processus de révision"
  decision          ReviewDecision?
  isCompleted       Boolean         @default(false) // Ajouté : pour suivre si la tâche est terminée
  reviewDate        DateTime? // Ajouté : La date à laquelle la révision a été effectuée
  dueDate           DateTime? // Date de limite de révision
  documentVersionId String          @db.ObjectId
  documentVersion   DocumentVersion @relation(name: "ReviewDocumentVersion", fields: [documentVersionId], references: [id], onDelete: Cascade)
  isNotified        Boolean         @default(false)
  notifiedAt        DateTime?
  completedAt       DateTime?

  document      Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  reviewer      User     @relation(fields: [reviewerId], references: [id], onDelete: Cascade)
  assignedBy    User?    @relation("Assigner", fields: [assignedById], references: [id])
  completedById String?  @db.ObjectId
  completedBy   User?    @relation(name: "ReviewCompletedBy", fields: [completedById], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([documentId])
  @@index([reviewerId])
  @@index([documentVersionId])
  @@map("document_reviews")
}

// Ce modèle est la piste d'audit des approbations.
model DocumentApproval {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  documentId String   @db.ObjectId
  approverId String   @db.ObjectId
  versionId  String   @db.ObjectId
  approvedAt DateTime @default(now())

  document Document        @relation(fields: [documentId], references: [id])
  version  DocumentVersion @relation(fields: [versionId], references: [id])
  approver User            @relation(fields: [approverId], references: [id])

  @@unique([documentId, versionId, approverId])
  @@map("document_approvals")
}

// Les notifications sont essentielles pour les rappels et les alertes.
enum NotificationType {
  REVIEW_NEEDED
  REVIEW_OVERDUE
  DOCUMENT_APPROVED
  DOCUMENT_UPDATED
}

model Notification {
  id         String           @id @default(auto()) @map("_id") @db.ObjectId
  userId     String           @db.ObjectId
  type       NotificationType
  title      String
  message    String
  isRead     Boolean          @default(false)
  documentId String?          @db.ObjectId // Ajouté : Pour lier la notification à un document
  createdAt  DateTime         @default(now())

  user     User      @relation(fields: [userId], references: [id])
  document Document? @relation(fields: [documentId], references: [id])

  @@map("notifications")
}

// ===========================================================================================
// AUDIT LOGS
// ===========================================================================================

enum AuditEventType {
  // Auth
  AUTH_LOGIN_ATTEMPT
  AUTH_LOGIN
  AUTH_LOGOUT
  // Document
  DOCUMENT_UPDATE
  DOCUMENT_EDIT
  DOCUMENT_CREATE
  DOCUMENT_DELETE
  // Document version
  DOCUMENT_VERSION_CREATED
  DOCUMENT_VERSION_APPROVED
  DOCUMENT_VERSION_REJECTED

  DOCUMENT_STATUS_CHANGE
  DOCUMENT_REVIEW_SUBMITTED
  // User
  USER_UPDATE
  USER_ADD
  USER_DELETE
  // Departement
  DEPARTMENT_CREATE
  DEPARTMENT_UPDATE
  DEPARTMENT_DELETE
  // Action
  ACCESS_LOG // Journal d'accès au document
  EXPORT_LOGS // Exportation des journaux
}

enum AuditStatus {
  SUCCESS
  FAILURE
}

enum AuditTargetType {
  DOCUMENT
  USER
  DEPARTMENT
  VERSION
  REVIEW
  APPROVAL
}

type AuditTarget {
  id   String          @db.ObjectId
  type AuditTargetType
}

model AuditLog {
  id        String         @id @default(auto()) @map("_id") @db.ObjectId
  userId    String?        @db.ObjectId
  eventType AuditEventType
  details   Json?          @default("{}")
  targets   AuditTarget[]
  ipAddress String?
  userAgent String?
  status    AuditStatus    @default(SUCCESS)
  sessionId String?
  timestamp DateTime       @default(now())
  user      User?          @relation(fields: [userId], references: [id])

  @@index([userId, eventType, timestamp])
  @@map("audit_logs")
}

model GoogleAccount {
  id           String  @id @default(auto()) @map("_id") @db.ObjectId
  email        String  @unique
  googleId     String
  tokens       Json    @default("{}")
  workingDirId String
  isLoggedIn   Boolean @default(true)

  createdAt DateTime @default(now())

  @@map("google_accounts")
}

model RecentlyViewedDocument {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  viewedAt   DateTime @default(now())
  documentId String   @db.ObjectId
  userId     String   @db.ObjectId

  document Document @relation(fields: [documentId], references: [id])
  user     User     @relation(fields: [userId], references: [id])

  @@map("recently_viewed_documents")
}


// ===========================================================================================
// COMPLIANCE / CONFORMITE ISO 27001
// ===========================================================================================

enum ComplianceStatus {
  COMPLIANT
  NON_COMPLIANT
  WARNING
}

model DocumentCompliance {
  id          String           @id @default(auto()) @map("_id") @db.ObjectId
  documentId  String           @db.ObjectId
  status      ComplianceStatus @default(COMPLIANT)
  description String?
  checkedAt   DateTime         @default(now())

  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId, status])
  @@map("document_compliance")
}

enum NonConformityType {
  DOCUMENT_EXPIRED
  REVIEW_OVERDUE
  UNAUTHORIZED_ACCESS
  MISSING_APPROVAL
  OTHER
}

enum NonConformityStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

model NonConformity {
  id          String             @id @default(auto()) @map("_id") @db.ObjectId
  type        NonConformityType
  status      NonConformityStatus @default(OPEN)
  description String?
  detectedAt  DateTime @default(now())
  resolvedAt  DateTime?

  documentId String? @db.ObjectId
  userId     String? @db.ObjectId

  document Document? @relation(fields: [documentId], references: [id])
  user     User?     @relation(fields: [userId], references: [id])

  correctiveActions CorrectiveAction[]

  @@map("non_conformities")
}

enum ActionStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
}

model CorrectiveAction {
  id              String       @id @default(auto()) @map("_id") @db.ObjectId
  nonConformityId String       @db.ObjectId
  description     String
  ownerId         String?      @db.ObjectId
  dueDate         DateTime?
  status          ActionStatus @default(PENDING)
  completedAt     DateTime?

  nonConformity NonConformity @relation(fields: [nonConformityId], references: [id], onDelete: Cascade)
  owner         User?          @relation(fields: [ownerId], references: [id])

  @@map("corrective_actions")
}

enum ClauseComplianceStatus {
  COMPLIANT
  PARTIALLY_COMPLIANT
  NON_COMPLIANT
  NOT_APPLICABLE
}

model ClauseCompliance {
  id          String                 @id @default(auto()) @map("_id") @db.ObjectId
  isoClauseId String                 @db.ObjectId
  status      ClauseComplianceStatus @default(COMPLIANT)
  evidence    String?
  checkedAt   DateTime               @default(now())

  isoClause ISOClause @relation(fields: [isoClauseId], references: [id], onDelete: Cascade)

  @@map("clause_compliance")
}
