// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-1.1.x"]
  // output   = "../src/generated/prisma"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

// ===========================================================================================
// DEPARTMENT
// ===========================================================================================
model Department {
  id          String  @id @default(auto()) @map("_id") @db.ObjectId
  name        String  @unique
  description String?

  roles DepartmentRole[] @relation()

  createdById String? @db.ObjectId
  createdBy   User?   @relation(name: "CreatedDepartments", fields: [createdById], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("departments")
}

model DepartmentRole {
  id          String  @id @default(auto()) @map("_id") @db.ObjectId
  name        String  @unique
  description String?

  departmentId String     @db.ObjectId
  department   Department @relation(fields: [departmentId], references: [id], onDelete: Cascade)

  createdById String? @db.ObjectId
  createdBy   User?   @relation("DepartmentRolesCreated", fields: [createdById], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  departmentRoleDocuments DepartmentRoleDocument[]
  departmentRoleUsers     DepartmentRoleUser[]

  @@unique([departmentId, name]) // un rôle est unique par département
  @@map("department_roles")
}

// ===========================================================================================
// USERS MANAGEMENT AND ROLES
// ===========================================================================================

enum RoleType {
  ADMIN
  CONTRIBUTOR
  REVIEWER
  VIEWER
}

model User {
  id           String    @id @default(auto()) @map("_id") @db.ObjectId
  email        String    @unique
  name         String?
  role         RoleType  @default(VIEWER)
  isActive     Boolean   @default(false)
  lastLogin    DateTime?
  // ssoId        String?   @unique
  passwordHash String?

  passwordResetToken String?

  // Who created this user
  createdById String? @db.ObjectId
  createdBy   User?   @relation("CreatedUsers", fields: [createdById], references: [id], onDelete: NoAction, onUpdate: NoAction)

  //Relation
  documentReviews   DocumentReview[]
  documentApprovals DocumentApproval[]
  notifications     Notification[]
  auditLogs         AuditLog[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  departmentRoleUsers DepartmentRoleUser[]

  metadata                Json?
  documentAuthors         DocumentAuthor[]   @relation("DocumentAuthorUser")
  documentReviewers       DocumentReviewer[] @relation("DocumentReviewerUser")
  assignedDocumentReviews DocumentReview[]   @relation("Assigner")
  reviewsCompleted        DocumentReview[]   @relation("ReviewCompletedBy")
  createdVersions         DocumentVersion[]  @relation("VersionCreatedByUser")

  // Reverse relations: must break referential action cycles
  createdUsers           User[]           @relation("CreatedUsers")
  invitationsSent        Invitation[]     @relation("InvitationsSent")
  createdDocumentTypes   DocumentType[]   @relation("CreatedDocumentTypes")
  createdDepartments     Department[]     @relation("CreatedDepartments")
  createdDepartmentRoles DepartmentRole[] @relation("DepartmentRolesCreated")
  createdISOClauses      ISOClause[]      @relation("CreatedISOClauses")

  @@index([email, isActive])
  @@index([role])
  @@map("users")
}

// Relation between document and department role
model DepartmentRoleDocument {
  id               String @id @default(auto()) @map("_id") @db.ObjectId
  departmentRoleId String @db.ObjectId
  documentId       String @db.ObjectId

  // Prisma relations
  document       Document       @relation(fields: [documentId], references: [id], onDelete: Cascade)
  departmentRole DepartmentRole @relation(fields: [departmentRoleId], references: [id], onDelete: Cascade)

  @@map("departmentrole_documents")
}

// Relation between user and department role
model DepartmentRoleUser {
  id               String @id @default(auto()) @map("_id") @db.ObjectId
  departmentRoleId String @db.ObjectId
  userId           String @db.ObjectId

  // Prisma relations
  user           User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  departmentRole DepartmentRole @relation(fields: [departmentRoleId], references: [id], onDelete: Cascade)

  @@map("departmentrole_users")
}

model Invitation {
  id          String           @id @default(auto()) @map("_id") @db.ObjectId
  email       String
  token       String           @unique
  status      InvitationStatus @default(PENDING)
  invitedBy   User             @relation(name: "InvitationsSent", fields: [invitedById], references: [id])
  invitedById String           @db.ObjectId
  acceptedAt  DateTime?
  expiresAt   DateTime
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  @@map("invitations")
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  EXPIRED
  CANCELED
}

// ===========================================================================================
// DOCUMENTS MANAGEMENT AND POLITICS
// ===========================================================================================

model DocumentType {
  id          String     @id @default(auto()) @map("_id") @db.ObjectId
  name        String     @unique
  description String?
  // isoClauseNumber String?
  documents   Document[]

  createdById String? @db.ObjectId
  createdBy   User?   @relation(name: "CreatedDocumentTypes", fields: [createdById], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("document_types")
}

enum DocumentStatus {
  DRAFT
  IN_REVIEW
  APPROVED
  EXPIRED
}

enum ReviewFrequency {
  DAILY
  WEEKLY
  MONTHLY
  QUARTERLY
  SEMI_ANNUAL
  YEARLY
  BIENNIAL
  AS_NEEDED
}

enum Classification {
  CONFIDENTIAL
  INTERNAL_USE_ONLY
  PUBLIC
}

model Document {
  id              String           @id @default(auto()) @map("_id") @db.ObjectId
  title           String
  description     String?
  fileUrl         String?
  status          DocumentStatus   @default(DRAFT)
  nextReviewDate  DateTime?
  reviewFrequency ReviewFrequency?
  isoClauseId     String           @db.ObjectId

  published       Boolean   @default(false)
  publicationDate DateTime?

  classification Classification @default(CONFIDENTIAL)

  departmentRoles DepartmentRoleDocument[]

  categoryId String?       @db.ObjectId
  ownerId    String        @db.ObjectId
  owner      DocumentOwner @relation(name: "DocumentOwner", fields: [ownerId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  isoClause     ISOClause          @relation(fields: [isoClauseId], references: [id])
  type          DocumentType?      @relation(fields: [categoryId], references: [id])
  versions      DocumentVersion[]
  reviews       DocumentReview[]
  approvals     DocumentApproval[]
  notifications Notification[]
  auditlogs     AuditLog[]
  reviewers     DocumentReviewer[] @relation("DocumentReviewerDocument")

  authors DocumentAuthor[] @relation("DocumentAuthorDocument")

  @@index([title])
  @@map("documents")
}

model DocumentOwner {
  id   String  @id @default(auto()) @map("_id") @db.ObjectId
  name String  @unique
  logo String?

  documents Document[] @relation("DocumentOwner")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("document_owners")
}

model DocumentAuthor {
  id         String @id @default(auto()) @map("_id") @db.ObjectId
  documentId String @db.ObjectId
  userId     String @db.ObjectId

  document Document @relation(name: "DocumentAuthorDocument", fields: [documentId], references: [id], onDelete: Cascade)
  user     User     @relation(name: "DocumentAuthorUser", fields: [userId], references: [id], onDelete: Cascade)

  @@map("document_authors")
}

model DocumentReviewer {
  id         String @id @default(auto()) @map("_id") @db.ObjectId
  documentId String @db.ObjectId
  userId     String @db.ObjectId

  document Document @relation(name: "DocumentReviewerDocument", fields: [documentId], references: [id], onDelete: Cascade)
  user     User     @relation(name: "DocumentReviewerUser", fields: [userId], references: [id], onDelete: Cascade)

  @@map("document_reviewers")
}

model ISOClause {
  id          String     @id @default(auto()) @map("_id") @db.ObjectId
  code        String     @unique
  name        String
  description String?
  documents   Document[]

  createdById String? @db.ObjectId
  createdBy   User?   @relation(name: "CreatedISOClauses", fields: [createdById], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("iso_clauses")
}

model DocumentVersion {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  documentId  String   @db.ObjectId
  version     String
  comment     String?
  createdAt   DateTime @default(now())
  isCurrent   Boolean  @default(false) // optional: flag the latest version
  fileUrl     String?
  createdById String?  @db.ObjectId
  createdBy   User?    @relation(name: "VersionCreatedByUser", fields: [createdById], references: [id], onDelete: SetNull)

  document        Document           @relation(fields: [documentId], references: [id], onDelete: Cascade)
  approvals       DocumentApproval[]
  documentReviews DocumentReview[]   @relation("ReviewDocumentVersion")

  @@index([documentId, version])
  @@map("document_versions")
}

// ===========================================================================================
// REVIEWS SYSTEM, APPROVAL AND NOTIFICATIONS
// ===========================================================================================
enum ReviewDecision {
  APPROVE
  REJECT
  REQUEST_CHANGES
}

// Ce modèle est plus robuste et inclut l'état de la révision et les commentaire
model DocumentReview {
  id                String          @id @default(auto()) @map("_id") @db.ObjectId
  documentId        String          @db.ObjectId
  reviewerId        String          @db.ObjectId
  assignedById      String?         @db.ObjectId
  comment           String? // Ajouté : Pour "commenter une politique pendant le processus de révision"
  decision          ReviewDecision?
  isCompleted       Boolean         @default(false) // Ajouté : pour suivre si la tâche est terminée
  reviewDate        DateTime? // Ajouté : La date à laquelle la révision a été effectuée
  dueDate           DateTime? // Date de limite de révision
  documentVersionId String          @db.ObjectId
  documentVersion   DocumentVersion @relation(name: "ReviewDocumentVersion", fields: [documentVersionId], references: [id], onDelete: Cascade)
  isNotified        Boolean         @default(false)
  notifiedAt        DateTime?
  completedAt       DateTime?

  document      Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  reviewer      User     @relation(fields: [reviewerId], references: [id], onDelete: Cascade)
  assignedBy    User?    @relation("Assigner", fields: [assignedById], references: [id])
  completedById String?  @db.ObjectId
  completedBy   User?    @relation(name: "ReviewCompletedBy", fields: [completedById], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([documentId])
  @@index([reviewerId])
  @@index([documentVersionId])
  @@map("document_reviews")
}

// Ce modèle est la piste d'audit des approbations.
model DocumentApproval {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  documentId String   @db.ObjectId
  approverId String   @db.ObjectId
  versionId  String   @db.ObjectId
  approvedAt DateTime @default(now())

  document Document        @relation(fields: [documentId], references: [id])
  version  DocumentVersion @relation(fields: [versionId], references: [id])
  approver User            @relation(fields: [approverId], references: [id])

  @@unique([documentId, versionId, approverId])
  @@map("document_approvals")
}

// Les notifications sont essentielles pour les rappels et les alertes.
enum NotificationType {
  REVIEW_NEEDED
  REVIEW_OVERDUE
  DOCUMENT_APPROVED
  DOCUMENT_UPDATED
}

model Notification {
  id         String           @id @default(auto()) @map("_id") @db.ObjectId
  userId     String           @db.ObjectId
  type       NotificationType
  title      String
  message    String
  isRead     Boolean          @default(false)
  documentId String?          @db.ObjectId // Ajouté : Pour lier la notification à un document
  createdAt  DateTime         @default(now())

  user     User      @relation(fields: [userId], references: [id])
  document Document? @relation(fields: [documentId], references: [id])

  @@map("notifications")
}

// ===========================================================================================
// AUDIT LOGS
// ===========================================================================================

enum AuditEventType {
  // Document
  DOCUMENT_UPLOAD
  DOCUMENT_UPDATE
  DOCUMENT_VERSION_CREATED
  DOCUMENT_STATUS_CHANGE
  DOCUMENT_REVIEW_SUBMITTED
  // User
  USER_ROLE_CHANGE
  USER_ADD
  USER_DELETE
  // Action
  ACCESS_LOG // Journal d'accès au document
  EXPORT_LOGS // Exportation des journaux
}

enum AuditStatus {
  SUCCESS
  FAILED
}

model AuditLog {
  id            String         @id @default(auto()) @map("_id") @db.ObjectId
  userId        String?        @db.ObjectId
  eventType     AuditEventType
  documentId    String?        @db.ObjectId
  details       Json?
  ipAddress     String?
  userAgent     String?
  status        AuditStatus @default(SUCCESS)
  sessionId     String?
  timestamp     DateTime       @default(now())

  user          User?          @relation(fields: [userId], references: [id])
  document      Document?      @relation(fields: [documentId], references: [id])

  @@index([userId, documentId, eventType, timestamp])
  @@map("audit_logs")
}
